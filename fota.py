"""
.. module:: aws_iot_fota

************************************
Amazon Web Services IoT FOTA Library
************************************

The Zerynth AWS IoT FOTA Library can be used to implement Firmware Over The Air updates (FOTA) of AWS Things with ease.

Devices connected to the AWS IoT MQTT Broker can receive jobs containing enough information for a firmware update. Such jobs can be easily generated by the :ref:`ZTC <ztc-cmd-aws-iot_fota_start>`.

The FOTA flow is quite simple:

    * A device is notified of a new job
    * The job document must contain the following required fields:

        * :samp:`bc_idx`, the index of the bytecode slot to save the new firmware to
        * :samp:`bc_crc`, the MD5 crc of the new firmware
        * :samp:`bc_size`, the length in bytes of the new firmware
        * :samp:`bc_url`, a https url to a S3 file containing the new firmware

    * If the job can be performed, it is placed in the IN_PROGRESS status. Otherwise it is mared as FAILED and the flow stops.
    * The firmware is downloaded from :samp:`bc_url`, saved to the device and checked for errors against :samp:`bc_crc`
    * The device is restarted
    * If the new firmware is correct, the IN_PROGRESS job is retrieved and marked as SUCCEEDED. Otherwise the old working firmware will restart and will mark the job as FAILED.

The entire flow can be managed as in the following example: ::

    from aws.iot import fota as awsfota
    from aws.iot import jobs

    ...
    do some initialization (connect to the network and configure the Thing)
    ...
    
    # create an IoT Jobs object
    myjobs = jobs.Jobs(thing)
    
    # check if there are FOTA jobs waiting to be performed
    # This function executes a FOTA update if possible
    # or confirms an already executed FOTA update
    awsfota.handle_fota_jobs(myjobs, force=True)  # True, force

    while True:
        r = random(0,10)
        print('publish random sample...',r)
        thing.mqtt.publish("dev/sample", json.dumps({ 'asample': r }))
        sleep(publish_period)

        # check for new incoming jobs
        # again, FOTA is executed if a correct FOTA job is queued
        awsfota.handle_fota_jobs(myjobs)

    """

import fota
import ssl
import requests
import mcu
from aws.iot import jobs

next_bcaddr = 0
bcsize = 0
wsize = 0

def _stream_cb(content):
    global next_bcaddr
    global wsize
    fota.write_slot(next_bcaddr+wsize,content)
    wsize+=len(content)


def is_fota_possible(data):
    try:
        record = fota.get_record()
        if data["bc_idx"]!=record[4]:
            #check that fota is not for current slot
            return True
    except Exception as e:
        print(e)
        return False
    return False

def is_fota_valid(data):
    try:
        record = fota.get_record()
        print(record)
        print(data)
        if data["bc_idx"]==record[4] and data["bc_idx"]!=record[5]:
            #check that fota is for current slot
            #and that it is coming from previous slot
            return True
    except Exception as e:
        print(e)
        return False
    return False
    

def update(fota_data):
    """
.. function:: update(document)

    Given a correct job :samp:`document`, performs the FOTA update by downloading the correct firmware from the signed S3 bucket url
    and checking if the download was correct against the firmware CRC. Return True if the process finishes correctly.
    
    """
    global next_bcaddr
    global bcsize
    # setup 
    awscert = __lookup(SSL_CACERT_BALTIMORE_CYBERTRUST_ROOT)
    ctx = ssl.create_ssl_context(cacert=awscert,options=ssl.CERT_REQUIRED|ssl.SERVER_AUTH)
    record = fota.get_record()
    chunk = record[8]

    #prepare for FOTA
    next_bcaddr = fota.find_bytecode_slot()
    bcsize = fota_data["bc_size"]
    fota.erase_slot(next_bcaddr, bcsize)
    
    url = fota_data["bc_url"]
    rr = requests.get(url, ctx=ctx, stream_callback=_stream_cb, stream_chunk=chunk)
    if wsize!=bcsize:
        return False
    chk = fota.checksum_slot(next_bcaddr,bcsize)
    fota.close_slot(next_bcaddr)
    for i,b in enumerate(chk):
        k = int(fota_data["bc_crc"][i*2:i*2+2],16)
        if k!=b:
            print("Bad crc!")
            break

    return True

def test(fota_data):
    """
.. function:: test(document)

    Must be called after a successful :ref:`update` to test the new firmware providing the job :samp:`document`. Once called, a device reset is necessary.
    
    """
    record = fota.get_record()
    #new bytecode, current vm
    fota.attempt(fota_data["bc_idx"],record[1])

def confirm():
    """
.. function:: confirm()

    Makes the new firmware final. Must be called by the new firmware upon reset after the old firmware called :ref:`test`. Failing to confirm the new firmware will reboot the old firmware on reset.
    
    """
    fota.accept()

def reset():
    """
.. function:: reset()
   
   Reset the device

    """
    mcu.reset()



def handle_fota_jobs(jbs,force=False,disconnect_mqtt=True,auto_reset=True,job_cbk=None):
    """
.. function:: handle_fota_jobs(jobs,force=False,disconnect_mqtt=True,auto_reset=True,job_cbk=None)

    The entire FOTA flow can be implemented by adding this function to an AWS ready firmware.
    
    The function arguments:

    * :samp:`jobs`, is an instance of the Jobs class (module aws.iot.jobs) properly initialized with the current Thing
    * :samp:`force`, if True forces the retrieval of pending and queued jobs regardless of a mqtt notification of the new jobs event
    * :samp:`disconnect_mqtt`, determines if th mqtt connection of the current Thing is closed before attempting a FOTA. By default it is set to True since keeping two TLS sockets open (one to the MQTT broker and the other to the S3 bucket) can be demanding for most devices.
    * :samp:`auto_reset`, automatically resets the device when the FOTA flow requires it. By default is set to True, however it can be disabled and the needed reset can be performed manually. A reset is signaled by :ref:`handle_fota_jobs` returning True.
    * :samp:`job_cbk`, is the job callback. Each non-FOTA job is passed to :samp:`job_cbk` for external handling if :samp:`job_cbk` is not None

    The function must be called at least twice: the first time, right after the connection to the mqtt broker with :samp:`force=True` in order to handle all pending jobs. The second call can be made periodically in the publish loop to catch new queued jobs.

    """
    if not jbs.changed() and not force: 
        return
    ongoing,queued = jbs.list()
    
    if ongoing:
        #handle ongoing jobs
        for job in ongoing:
            print("Checking ongoing job",job)
            ret = job.describe()
            if ret and job.document["operation"]=="fota":
                print("Job asks for FOTA confirmation of bytecode slot",job.document["bc_idx"])
                if is_fota_valid(job.document):
                    confirm()
                    print("Job SUCCEEDED")
                    job.update(jobs.Job.SUCCEEDED)
                else:
                    print("Job FAILED")
                    job.update(jobs.Job.FAILED,{"reason":"invalid fota"})
                if auto_reset:
                    reset()
                return True
            elif ret and job_cbk is not None:
                job_cbk(job)

    
    if queued:
        #handle queued jobs
        for job in queued:
            print("Checking queued job",job)
            ret = job.describe()
            if ret and job.document["operation"]=="fota":
                print("Job asks for FOTA of bytecode to slot",job.document["bc_idx"])
                if not is_fota_possible(job.document):
                    print("Job FAILED")
                    job.update(jobs.Job.FAILED,{"reason":"bad fota data"})
                    continue
                #fota document makes sense, go on
                print("Job IN PROGRESS")
                job.update(jobs.Job.IN_PROGRESS)
                if disconnect_mqtt:
                    #disconnect mqtt
                    job.thing.mqtt.disconnect()
                    job.thing.mqtt.close()
                #perform fota
                print("Downloading firmware...")
                ret = update(job.document)
                if ret:
                    #let's test new firmware!
                    #it must reboot and finalize the in progress fota job
                    print("Firmware written correctly")
                    test(job.document)
                else:
                    #don't call test()
                    #device will reset and fail the ongoing job
                    print("Firmware not correctly written. Job will FAIL on reset")
                #signal reset!
                if auto_reset:
                    reset()
                return True
            elif ret and job_cbk:
                job_cbk(job)


    

